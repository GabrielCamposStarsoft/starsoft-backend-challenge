================================================================================
            REVIEW TÉCNICO - STARSOFT BACKEND CHALLENGE
            Sistema de Venda de Ingressos de Cinema
            (Revisão v5 – estado atual do código)
================================================================================


============================================================
  PONTOS FORTES
============================================================

1. CONTROLE DE CONCORRÊNCIA NA RESERVA (create-reservations.use-case.ts)
   UPDATE atômico condicional:
     UPDATE seats SET status = 'reserved'
     WHERE id = :seatId AND session_id = :sessionId AND status = 'available'
   Com PostgreSQL em READ COMMITTED, transações concorrentes no mesmo assento
   bloqueiam na linha; após commit da primeira, o WHERE da segunda falha
   (affected = 0) e ConflictException é lançada. Garante que nenhum assento
   seja vendido duas vezes no nível de reserva.

2. ORDENAÇÃO DE SEATS PARA PREVENÇÃO DE DEADLOCK
   const sortedSeatIds = [...seatIds].sort() antes de iterar garante ordem
   consistente de aquisição de locks entre usuários (ex.: [1,3] vs [3,1]).
   Evita deadlock circular.

3. OUTBOX PATTERN NO PAGAMENTO (create-sales.use-case.ts)
   QueryRunner manual, pessimistic write lock na reserva e no assento,
   SaleOutboxEntity gravada na mesma transação que a venda, commit atômico.
   Relay com scheduler + DistributedLock (Redlock). Eventos publicados
   somente após persistência.

4. OUTBOX PATTERN NA RESERVA
   ReservationOutboxEntity criada na mesma transação da reserva.
   RelayReservationCreatedOutboxUseCase processa reservation_events_outbox,
   publica ReservationCreated no RabbitMQ e marca published = true.
   ReservationOutboxRelayService orquestra use cases (sem repositório direto);
   scheduler com @DistributedLock('lock:reservation-outbox-relay', 25).

5. OUTBOX PATTERN NA EXPIRAÇÃO
   ReservationExpirationOutboxEntity gravada na mesma transação que o update
   da reserva (EXPIRED) e do seat (AVAILABLE). RelayReservationExpirationOutboxUseCase
   processa reservation_expiration_outbox, publica ReservationExpired e
   SeatReleased (quando seatReleased), marca published. Eventos não se perdem
   se a aplicação cair entre commit e publish.

6. EXPIRAÇÃO DE RESERVAS (expire-reservations.use-case.ts)
   Transação por reserva, lock pessimista na reserva, UPDATE atômico no seat
   com WHERE status = 'reserved'. version: () => 'version + 1'. Inserção no
   expiration outbox na mesma transação (sem publish direto). Try/catch por
   reserva para não quebrar o batch. Scheduler a cada 10s (EVERY_10_SECONDS)
   para SLA ~30s + 10s; @DistributedLock com TTL 8s.

7. DISTRIBUTED LOCK (Redlock)
   DistributedLockService com cleanup em onModuleDestroy. Decorator
   @DistributedLock(key, ttlSeconds) + interceptor. Usado nos schedulers
   de expiração e de outbox relay (reservas e vendas).

8. VENDAS IMUTÁVEIS
   SalesController expõe apenas POST e GET; sem PUT/DELETE, alinhado ao
   domínio de vendas confirmadas.

9. AUTENTICAÇÃO COMPLETA
   AuthModule com JWT (access + refresh token opaco), Argon2 no hash de senha,
   Passport (JwtStrategy), JwtAuthGuard, JwtRefreshGuard, registro, login,
   refresh, logout. Refresh tokens armazenados hasheados. Fluxo em use-cases
   (AuthService sem injeção direta de repositório). Rota GET /auth/me protegida
   como exemplo.

10. I18N
   nestjs-i18n com estrutura por idioma (en/, pt/), common.json e validation.json,
   resolvers (query lang, header x-lang, Accept-Language). I18nValidationPipe
   e I18nValidationExceptionFilter para mensagens de validação traduzidas.
   Path resolvido para dev (src/i18n) e prod (dist/i18n) com assets no nest-cli.

11. SEPARAÇÃO EM USE CASES
    Operações de negócio em Use Cases (IUseCase<Input, Output>). Controller ->
    Service -> Use Case. Auth e Reservations com use-cases bem definidos.

12. DOCKER E REDE
    compose.yml com api, db, valkey e rabbitmq na rede cinema_network.
    .env com VALKEY_URL=redis://valkey:6379 e RMQ_URL=amqp://guest:guest@rabbitmq:5672
    para uso no container. .dockerignore preenchido (node_modules, dist, testes,
    .git, .env, etc.) para contexto de build enxuto.

13. SEGURANÇA E CONVENÇÕES
    UsersResponseDto sem password. Senha com Argon2 em criação/atualização de
    usuário. Tipagem forte, sem any nos módulos principais.

14. ÍNDICES E ENTIDADES
    Índices em reservations (status, expiresAt), seats (session_id, label unique),
    sales (user_id). SaleOutboxEntity com jsonb. ReservationOutboxEntity e
    ReservationExpirationOutboxEntity registradas no ReservationsModule.

15. RATE LIMITING (Throttler)
    @nestjs/throttler com ThrottlerSkipPathsGuard global; skip em /api-docs e
    /health. Limites específicos para auth (login, register, refresh, logout).
    HealthModule com GET /health.

16. DOCUMENTAÇÃO DA API (Scalar)
    UI Scalar em /api-docs (apiReference com content do OpenAPI e withFastify).
    Documento gerado por SwaggerModule.createDocument; sem Swagger UI.


============================================================
  CORREÇÕES APLICADAS (desde a revisão anterior)
============================================================

- ReservationOutboxEntity registrada em TypeOrmModule.forFeature no ReservationsModule.
- ReservationOutboxRelayService e ReservationOutboxRelayScheduler implementados;
  eventos de reserva criada passam a ser publicados no RabbitMQ e marcados como publicados.
- Variáveis de ambiente para Docker: VALKEY_URL e RMQ_URL apontando para os serviços
  na rede (valkey, rabbitmq). JWT_SECRET e expirações no .env.
- Autenticação implementada de ponta a ponta (registro, login, refresh, logout, guards).
- SalesController sem PUT/DELETE; vendas tratadas como imutáveis.
- Expiração de reservas com transação por reserva, lock na reserva e update atômico
  no seat; publicação de eventos apenas quando há alteração.
- Distributed lock com Redlock e decorator @DistributedLock nos schedulers.
- Módulo de outbox de vendas próprio no SalesModule (SaleOutboxEntity, OutboxRelayService,
  OutboxRelayScheduler); sem módulo outbox genérico espalhado.
- Hash de senha com Argon2 em criação e atualização de usuário.
- i18n com estrutura en/pt, resolvers e validação traduzida.
- .dockerignore definido para reduzir contexto de build.
- Cron de expiração alterado para EVERY_10_SECONDS; lock 8s (SLA ~30s + 10s).
- Outbox para expiração: ReservationExpirationOutboxEntity; eventos gravados
  na mesma transação em expire-reservations.use-case; relay em
  RelayReservationExpirationOutboxUseCase (ReservationExpired + SeatReleased).
- Relay de reservas em use cases: RelayReservationCreatedOutboxUseCase e
  RelayReservationExpirationOutboxUseCase; ReservationOutboxRelayService
  apenas orquestra, sem acesso direto a repositórios.
- Documentação da API com UI Scalar em /api-docs (@scalar/nestjs-api-reference).
- Rate limiting com @nestjs/throttler; ThrottlerSkipPathsGuard; limites em auth;
  HealthModule com /health e skip de throttle.
- Migration para reservation_expiration_outbox (1739180000000-CreateReservationExpirationOutbox).
- HealthModule com GET /health; healthchecks no compose (db, valkey, rabbitmq, api);
  api depende de condition: service_healthy dos demais; container_name da api
  removido para permitir scale (ex.: docker compose up --scale api=2).
- IdempotencyInterceptor: valor do cache sempre gravado como string
  (JSON.stringify); na leitura, normalização (string → JSON.parse, objeto → uso
  direto) para retornar sempre o mesmo tipo e manter Content-Type consistente.
- Microserviço Redis órfão removido do main.ts: apenas connectMicroservice
  (Transport.RMQ) é usado; não há createMicroservice(Transport.REDIS).


============================================================
  PROBLEMAS / PENDÊNCIAS
============================================================

--------------------------------------------------------------
1. README NÃO PERSONALIZADO (ALTO para aderência ao desafio)
--------------------------------------------------------------
Onde: README.md.
O desafio exige seções como: Visão Geral, Tecnologias e justificativas, Como
Executar, Estratégias (concorrência, deadlocks), Endpoints com exemplos,
Decisões Técnicas, Limitações, Melhorias Futuras. O README ainda é o template
padrão do NestJS.

--------------------------------------------------------------
2. SEM TESTES AUTOMATIZADOS (ALTO para diferenciais)
--------------------------------------------------------------
Onde: test/.
Não há testes unitários dos use cases nem de integração do fluxo reserva ->
pagamento -> venda. Nenhum script ou coleção que demonstre concorrência e
rejeição de duplicatas.

--------------------------------------------------------------
3. AppDataSource / MIGRATIONS (BAIXO)
--------------------------------------------------------------
Onde: main.ts, app.module.ts.
AppDataSource.initialize() e runMigrations() em dev. Existe migration para
reservation_expiration_outbox; demais tabelas podem depender de synchronize
quando DATABASE_SYNC=true. DataSource injetado no AppModule não é usado.

--------------------------------------------------------------
4. @VersionColumn NÃO USADO EFETIVAMENTE (BAIXO)
--------------------------------------------------------------
Onde: seats e reservation entities.
O locking efetivo é via UPDATE condicional e locks pessimistas. O @VersionColumn
não é usado de forma que garanta optimistic locking nos fluxos críticos.
Considerar remover ou documentar que é apenas informativo.

============================================================
  CHECKLIST DE ADERÊNCIA AO DESAFIO
============================================================

[ OK ] Nenhum assento vendido duas vezes (conditional UPDATE + locks).
[ OK ] Reserva com TTL; expiração com lock e update atômico no seat.
[ OK ] Mensageria RabbitMQ; eventos de reserva criada e pagamento confirmado.
[ OK ] Outbox para reserva e para venda; relay com distributed lock.
[ OK ] Docker: api, db, valkey, rabbitmq na mesma rede; .env com hosts corretos.
[ OK ] Autenticação JWT com refresh token e guards.
[ OK ] i18n (en/pt) e validação traduzida.
[ OK ] .dockerignore para build enxuto.
[  ] README com seções exigidas pelo desafio.
[  ] Testes (unitários e/ou integração) e script de demonstração de concorrência.
[ OK ] Rate limiting (Throttler com limites em auth; skip em /api-docs e /health).
[ OK ] Healthchecks no compose; api com depends_on condition: service_healthy;
      múltiplas instâncias possíveis com docker compose up --scale api=2.


============================================================
  NOTAS E RECOMENDAÇÕES
============================================================

- O design de concorrência (conditional UPDATE, ordenação de locks, outbox,
  Redlock) está sólido e bem aplicado nos fluxos principais.
- A execução atual cobre: reserva, outbox de reserva e de expiração com relay
  em use cases, vendas imutáveis com outbox, expiração a cada 10s com outbox,
  auth completo, i18n, throttler, documentação Scalar em /api-docs.
- Para fechar aderência e diferenciais: README completo, testes e script de
  concorrência. Rate limiting, documentação (Scalar) e healthchecks no compose
  já implementados; microserviço Redis órfão já removido (main.ts usa apenas RMQ).


============================================================
  PRÓXIMOS PASSOS SUGERIDOS
============================================================

1. Escrever README com visão geral, stack, como rodar, estratégias de
   concorrência, endpoints e decisões técnicas.
2. Adicionar testes unitários (ex.: use cases com mocks) e um script ou
   coleção HTTP que simule reservas concorrentes e mostre rejeição de duplicata.
3. (Opcional) UNIQUE (seat_id, session_id) em sales: já presente na entidade
   (@Unique('uq_sales_seat_session')); migration 1739180100000 garante a
   constraint no banco quando synchronize está desativado.


================================================================================
                         FIM DO REVIEW v5
================================================================================
